[
{
	"uri": "//localhost:1313/vi/",
	"title": "AWS Blue/Green Deployment",
	"tags": [],
	"description": "",
	"content": "Triển khai Blue/Green pipeline trên nền tảng AWS Tổng quan Trong workshop này, chúng ta sẽ cùng nhau xây dựng một Blue/Green pipeline sử dụng AWS CodePipeline và AWS ECS.\nThời lượng: 150 phút. Cần chuẩn bị: git đã được cài đặt trên máy local, tài khoản GitHub, IDE, tài khoản AWS, IAM User/Role với AdministratorAcess. Nội dung Giới thiệu Các bước chuẩn bị AWS CodeCommit AWS CodeBuild AWS CodePipeline AWS CodeDeploy và AWS ECS Dọn dẹp tài nguyên Tài liệu tham khảo "
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "\nBlue/Green Deployment là một quy trình triển khai liên tục nhằm giảm thời gian chết và rủi ro bằng cách có hai môi trường production giống hệt nhau, được gọi là Blue và Green.\nGiả sử môi trường Blue đang hoạt động và môi trường Green không hoạt động. Khi nhà phát triển muốn phát hành bất kỳ code mới nào - bản phát hành tính năng mới, phiên bản mới của ứng dụng, v.v. - công việc trên phiên bản mới được thực hiện trong môi trường Green, trong khi phiên bản cũ được duy trì trong Blue. Khi quá trình phát hành mới kết thúc, bộ cân bằng tải sẽ chuyển tất cả lưu lượng sản xuất sang phiên bản Green và phiên bản Blue được duy trì như một bản sao lưu.\nƯu điểm của chiến lược Blue/Green Deployment là :\nTesting parity: tính năng này có nghĩa là các thử nghiệm phản ánh thực sự thực tế của sản xuất. Triển khai bất kỳ lúc nào: không có downtime có nghĩa là chúng ta có thể phát hành bất kỳ lúc nào. Không cần phải đợi các maintenance windows. Chuyển tiếp tức thì: người dùng được chuyển sang phiên bản mới ngay lập tức, hoặc gần như vậy. Mọi người đều xem bản phát hành mới nhất cùng một lúc. Khôi phục tức thì: phần chuyển tiếp hoạt động theo cả hai cách. Nếu chúng ta quyết định quay lại phiên bản trước, chúng ta có thể chuyển tất cả người dùng trở lại ngay lập tức. Hot standby: Blue-Green có thể cứu chúng ta khỏi các tình huống thảm họa. Giả sử rằng một trung tâm dữ liệu chuyển sang chế độ ngoại tuyến, chúng ta sẽ chuyển sang cái khác cho đến khi sự cố được khắc phục. Điều này sẽ hoạt động miễn là chúng ta đã có biện pháp phòng ngừa là không đặt Blue-Green vào cùng một vùng khả dụng. Postmortem: việc gỡ lỗi các bản phát hành không thành công rất khó khăn với việc triển khai tại chỗ. Khi đối mặt với downtime, ưu tiên luôn là trở lại trạng thái bình thường. Việc thu thập dữ liệu gỡ lỗi chỉ là thứ yếu, vì vậy nhiều thông tin có giá trị có thể bị mất trong quá trình khôi phục. Blue-green không gặp phải vấn đề này — Các lần khôi phục luôn giữ nguyên việc triển khai thất bại để phân tích. Song song với đó thì chiến lược này cũng có một vài nhược điểm, có thể kể đến:\nTiêu tốn nhiều tài nguyên do cần duy trì 2 môi trường cùng lúc khi triển khai Blue/Green Deployment đòi hỏi các service trên cả 2 môi trường sử dụng chung database, trong trường hợp code mới có tác động thay đổi cấu trúc database, cần xây dựng chiến lược đồng bộ sao cho cả hai môi trường có thể chạy cùng lúc mà không gặp sự cố. Với vấn đề này, ta có thể sử dụng liquibase để xây dựng giải pháp. A notice disclaimer\n"
},
{
	"uri": "//localhost:1313/vi/6-codedeploy/6.1-cluster/",
	"title": "Tạo ECS Cluster",
	"tags": [],
	"description": "",
	"content": "Tạo ECS Cluster Truy cập tới dịch vụ AWS Elastic Container Service, chọn Create cluster. Mục Cluster name, nhập FCJ_Cluster. Xác nhận cluster đã được tạo thành công "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.1-git_credentials/",
	"title": "Tạo HTTPS Git Credentials cho CodeCommit",
	"tags": [],
	"description": "",
	"content": "Với Git credential, bạn có thể tạo username và static password trong IAM Console mà bạn có thể sử dụng để truy cập AWS CodeCommit từ cmd, Git CLI hoặc bất kỳ công cụ Git nào hỗ trợ xác thực HTTPS.\nVì đây là static credentials nên chúng có thể được cached bằng cách sử dụng các công cụ quản lý mật khẩu có trong hệ điều hành local của bạn hoặc được lưu trữ trong tiện ích quản lý thông tin xác thực. Điều này cho phép bạn bắt đầu với AWS CodeCommit trong vòng vài phút. Bạn không cần tải xuống AWS CLI hoặc đặt cấu hình ứng dụng khách Git để kết nối với kho lưu trữ CodeCommit trên HTTPS. Bạn cũng có thể sử dụng username và password để kết nối với CodeCommit từ các công cụ của bên thứ ba hỗ trợ xác thực tên username và password, bao gồm các ứng dụng khách GUI Git phổ biến (như TowerUI) và IDE (như Eclipse, IntelliJ và Visual Studio).\nTạo HTTPS Git Credentials cho CodeCommit Từ root account, truy cập vào IAM console của IAM account mà bạn sẽ sử dụng cho bài lab này, chọn mục Security credentials. Ở phần HTTPS Git credentials for AWS CodeCommit, chọn Generate credentials Chọn Download credentials, và lưu nó ở nơi bạn có thể dễ dàng truy cập lại. "
},
{
	"uri": "//localhost:1313/vi/4-codebuild/4.1-ecr_repo/",
	"title": "Tạo private repo ECR",
	"tags": [],
	"description": "",
	"content": "Tạo private repo ECR Di chuyển tới dịch vụ Amazon Elastic Container Registry. Tại menu bên trái, trong mục Private registry, chọn Repositories, sau đó chọn Create repository. Tiếp tục: Mục Viability settings, chọn Private (mặc định). Mục Repository name, nhập fcj-image-repo. Kéo xuống chọn Create repository. Xác nhận private image repo đã được tạo thành công. Mở folder source code mà bạn đã tải về trong phần trước bằng IDE của bạn, sau đó: Mở file buildspec.yml, tại dòng 4, ECR_REPO_NAME, kiểm tra và thay thế tên repo fcj-image-repo bằng tên repo của bạn nếu bạn sử dụng tên khác, nếu không hãy giữ nguyên. Lưu lại file. "
},
{
	"uri": "//localhost:1313/vi/3-codecommit/3.1-repo/",
	"title": "Tạo repo CodeCommit",
	"tags": [],
	"description": "",
	"content": "Tạo repo CodeCommit Chuyển hướng tới CodeCommit console. Tại Repositories, chọn Create repository. Mục Repositorie name, nhập FCJ_Repo. Xác nhận repo đã được tạo thành công. Nhấn Clone URL, chọn Clone HTTPS và sang bước tiếp theo. "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Nội dung Tạo HTTPS Git Credentials cho CodeCommit Tạo Public subnet Tạo Security group Tạo Target group Tạo Application load balancer "
},
{
	"uri": "//localhost:1313/vi/3-codecommit/3.2-code/",
	"title": "Push code lên repo",
	"tags": [],
	"description": "",
	"content": "Tải về source code Truy cập vào https://github.com/HUNG-rushb/React-Calculator/releases/tag/v1 và tải về source code. Đây là Calculator App đơn giản được viết bằng React và chúng ta sẽ dùng để deploy. Tải về và giải nén nó trong thư mục mà bạn muốn làm việc. Kiểm tra các file có đầy đủ đủ giống như hình bên dưới hay không. Push code lên CodeCommit repo Bên trong thư mục đó: Chạy git init để tạo git repo. Chạy git remote add origin PASTE_HTTPS_REPO_LINK_HERE, thay thế PASTE_HTTPS_REPO_LINK_HERE bằng link HTTPS mà bạn đã copy ở phần trước. Chạy git add .. Chạy git commit -m \u0026quot;init\u0026quot; để commit code trên local (không có trong hình). Tiếp tục: Chạy git push origin master để đẩy code lên repo trên CodeCommit. Git sẽ hỏi bạn về Username và Password, đây chính là credentials trong file codecommit credentials mà ta đã tạo ở phần Tạo HTTPS Git Credentials cho CodeCommit. Mở file credentials lên, copy username và password vào cmd. Enter và xác nhận code đã được push lên thành công. Trở về tab mà bạn đang mở AWS, di chuyển tới dịch vụ CodeCommit và vào repo của bạn, bạn sẽ thấy code đã được push lên thành công. Trên menu bên trái, chọn Commits và kiểm tra commit gần nhất là của bạn, trong hình là init. "
},
{
	"uri": "//localhost:1313/vi/4-codebuild/4.2-build_project/",
	"title": "Tạo CodeBuild project",
	"tags": [],
	"description": "",
	"content": "Tạo CodeBuild project Di chuyển tới dịch vụ CodeBuild, ở menu bên trái chọn Build projects, sau đó chọn Create project. Sau đó: Mục Project name, nhập FCJ_Build_Project. Mục Source 1 - Primary, chọn provider AWS CodeCommit, sau đó chọn repo FCJ_Repo. Mục Branch, chọn master. Mở mục Additional configuration, sau đó tick chọn Enable this flag if you want to build Docker images or want your builds to get elevated privileges. Mục Buildspec, tick chọn Use a buildspec file, nhập buildspec.yml. Kéo xuống dưới và chọn Create build project. Xác nhận build project đã được tạo thành công. "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.2-public_subnet/",
	"title": "Tạo Public subnet",
	"tags": [],
	"description": "",
	"content": " Chuyển tới VPC console, và quan sát xem bạn đã có Default VPC hay chưa. Chọn Subnets tại bảng điều hướng bên trái, chọn Create subnet. Chọn Default VPC. Tạo subnet 1: Mục Subnet name, nhập fcj-subnet-1. Mục Availability zone, chọn us-east-1a. Mục IPv4 subnet CIDR block, nhập 172.31.200.0/24. Chọn Add new subnet, và tạo subnet 2: Mục Subnet name, nhập fcj-subnet-1. Mục Availability zone, chọn us-east-1b. Mục IPv4 subnet CIDR block, nhập 172.31.201.0/24. Chọn Add new subnet, và tạo subnet 3: Mục Subnet name, nhập fcj-subnet-1. Mục Availability zone, chọn us-east-1c. Mục IPv4 subnet CIDR block, nhập 172.31.202.0/24. Chọn Create subnet. Xác nhận 3 subnet đã được tạo thành công. "
},
{
	"uri": "//localhost:1313/vi/6-codedeploy/6.2-task_def/",
	"title": "Tạo Task definition",
	"tags": [],
	"description": "",
	"content": "Tạo Task definition Truy cập tới dịch vụ AWS Elastic Container Service, chọn Task definitions, sau đó chọn Create new task definition liên tục 2 lần. Mục Task definition family, nhập FCJ_Task_Definition. Mục Infrastructure requirements, thực hiện: Mục Launch type, chọn AWS Fargate. Mục Task size, CPU chọn .5 vCPU, Memory chọn 2GB. Mục Task role, chọn ecsTaskExecutionRole. Mục Task execution role, chọn ecsTaskExecutionRole. Truy cập AWS ECR, vào repo fci_image_repo và copy latest image URI như trong hình. Mục Containner - 1, thực hiện: Mục Name, nhập fcj_container. Mục Image URI, paste vào image URI mà bạn đã copy ở bước 4. Xác nhận task definition đã được tạo thành công. "
},
{
	"uri": "//localhost:1313/vi/3-codecommit/",
	"title": "AWS CodeCommit",
	"tags": [],
	"description": "",
	"content": "\nNội dung Tạo repo CodeCommit Push code lên repo "
},
{
	"uri": "//localhost:1313/vi/6-codedeploy/6.3-code/",
	"title": "Cập nhật code",
	"tags": [],
	"description": "",
	"content": "Cập nhật code Truy cập AWS ECS, vào Task definitions, và chọn task FCJ_Task_Definition mà ta đã tạo. Chọn tab JSON, sau đó Copy to clipboard. Từ source code, mở file taskdef.json trong IDE của bạn. Thay thế toàn bộ nội dung trong file đó bằng task definition mà bạn đã copy bước 1. Tại dòng số 6, nơi có key image, thay thế value của nó bằng \u0026lt;IMAGE1_NAME\u0026gt;. Kéo xuống cuối hoặc search trong IDE cụm từ tags, bạn sẽ tìm thấy \u0026ldquo;tags\u0026rdquo;: [], hãy xóa nó đi. Mở file appspec.yml, tại dòng số 8, ContainerName, thay thế value bằng fcj_container. Đây chính là tên container mà bạn đã đặt trong bước 5 phần 6.2, bạn cũng có thể tìm thấy \u0026ldquo;name\u0026rdquo;: \u0026ldquo;fcj_container\u0026rdquo; trong task definition ở file taskdef.json. Thực hiện đẩy code lên repo: Chạy git add .. Chạy git commit -m \u0026quot;Update config\u0026quot; để commit code trên local. Chạy git push origin master để đẩy code lên repo trên CodeCommit. Hãy mở pipeline của bạn và quan sát. Sau khi tất cả các stage thành công, hãy truy cập AWS S3, tìm và chọn bucket codepipeline-us-east-1-\u0026hellip;\u0026hellip;. Đây là bucket được CodePipeline tạo ra để lưu artifact. Mỗi region sẽ có 1 bucket tương ứng với region của pipeline. Chọn folder có tên pipeline FCJ_Pipeline. Chọn folder BuildArtif. Nhấn vào tab Last modified để sắp xếp theo thời gian, chọn vào item gần đây nhất, nhấn Download để tải về. Giải nén và kiểm tra xác nhận nội dung đã đúng với những gì bạn đã chỉnh sửa ở các bước trên. Nếu vậy thì artifact của chúng ta đã được build thành công. "
},
{
	"uri": "//localhost:1313/vi/4-codebuild/4.3-role/",
	"title": "Cập nhật quyền cho codebuild role",
	"tags": [],
	"description": "",
	"content": "Cập nhật quyền cho codebuild role Truy cập tới dịch vụ IAM: Ở menu bên trái, chọn Roles. Nhập tìm codebuild. Chọn role codebuild tương ứng với project của bạn. Chọn Add permissions, sau đó Create inline policy. Copy và paste policy dưới đây vào Policy editor. Sau đó kéo xuống dưới chọn Next. { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ecr-public:GetAuthorizationToken\u0026#34;, \u0026#34;sts:GetServiceBearerToken\u0026#34;, \u0026#34;ecr-public:BatchCheckLayerAvailability\u0026#34;, \u0026#34;ecr-public:GetRepositoryPolicy\u0026#34;, \u0026#34;ecr-public:DescribeRepositories\u0026#34;, \u0026#34;ecr-public:DescribeRegistries\u0026#34;, \u0026#34;ecr-public:DescribeImages\u0026#34;, \u0026#34;ecr-public:DescribeImageTags\u0026#34;, \u0026#34;ecr-public:GetRepositoryCatalogData\u0026#34;, \u0026#34;ecr-public:GetRegistryCatalogData\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Mục Policy name, nhập FCJ_ECR_Public_Access. Sau đó nhấn Create policy. Xác nhận policy đã được thêm thành công. Tiếp tục chọn Add permissions, sau đó Attach policies. Nhập tìm AmazonEC2ContainerRegistryFullAccess. Chọ và nhấn Add permissions. Xác nhận policy đã được thêm thành công. "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.3-security_group/",
	"title": "Tạo Security group",
	"tags": [],
	"description": "",
	"content": " Tạo Security group Chuyển tới Security Groups, chọn Create security group. Tạo security group: Mục Security group name, nhập FCJ_SG.\nMục Description, nhập Allow inbound HTTP on port 80.\nMục VPC, chọn Default VPC.\nMục Inbound rules, chọn Add rule, Type chọn HTTP, Source chọn Anywhere-IPv4.\nKéo xuống dưới cùng, chọn Create security group (không có trong hình).\n"
},
{
	"uri": "//localhost:1313/vi/4-codebuild/",
	"title": "AWS CodeBuild",
	"tags": [],
	"description": "",
	"content": " Nội dung Tạo private repo ECR Tạo CodeBuild project Cập nhật quyền cho codebuild role "
},
{
	"uri": "//localhost:1313/vi/6-codedeploy/6.4-service/",
	"title": "Tạo Cluster service",
	"tags": [],
	"description": "",
	"content": "Tạo Cluster service Truy cập tới AWS ECS, vào danh sách Clusters, và chọn cluster FCJ_Cluster. Chọn Create trong tab Services. Mục Compute options, chọn Launch type, và chọn Fargate (mặc định), Platform version là LATEST. Tại Deployment configuration: Mục Application type, chọn Service. Mục Family, chọn FCJ_Task_Definition, Revision tự động chọn bản LATEST. Mục Project name, chọn FCJ_Build_Project. Mục Service name, nhập FCJ_Service. Mục Desired tasks, nhập 3. Tiếp tục: Mục Deployment options, chọn Blue/green deployment (powered by AWS CodeDeploy). Mục Deployment configuration, chọn CodeDeployDefault.ECSLinear10PercentEvery1Minutes. Mục Service role for CodeDeploy, chọn CodeDeployServiceRole. Tại Networking: Mục VPC, chọn Default VPC. Mục Subnets, chọn 3 puclic subnet fcj-subnet-\u0026hellip;. Mục Security group, chọn Use an existing security group, sau đó chọn thêm FCJ_SG, sẽ có 2 security group như trong hình. Mục Public IP, chọn Turned on. Tại Load balancing: Mục Load balancer type, chọn Application Load Balancer. Mục Application Load Balancer, chọn Use an existing load balancer. Mục Load balancer, chọn FCJ_ALB. Mục Health check grace periodInfo, nhập 0. Tiếp tục: Mục Listeners, mục Production listener, chọn Use an existing listener và chọn 80:HTTP. Kiểm tra target group là FCJ_TG. Tại Target groups: Mục Application type, chọn Service. Mục Target group 1, chọn Use an existing target group và sau đó chọn FCJ_TG ở dropdown bên phải. Mục Target group 2, chọn Create new target group. Mục Target group 2 name, nhập FCJ-TG-Blue. Sau đó kéo xuống dưới cùng và chọn Create (không có trong hình). Truy cập tới dịch vụ AWS CloudFormation, chúng ta sẽ thấy có 1 stack mới đang được khởi tạo, đây chính là stack chứa service của chúng ta. Sau khi stack tạo thành công, truy cập tới dịch vụ AWS CodeDeploy, vào Applications, chúng ta sẽ thấy một application có dạng AppECS-\u0026hellip;. Đây là application mà ECS sử dụng để deploy ứng dụng. Nhấn vào application để quan sát. Chọn tab Deployment groups, chọn deployment group duy nhất trong đó, và chọn Edit. Kéo xuống bên dưới, tại phần Deployment settings, chình thời gian Original revision termination thành 0 hour 15 minutes như trong hình. Nhấn Save changes. Quay về ECS console, kiểm tra Services của cluster thì ta sẽ thấy FCJ_Service đang chạy thành công. Chuyển sang tab Tasks, chúng ta sẽ thấy có 3 task đang Running. Truy cập tới dịch vụ AWS EC2, tới Load balancers, chọn FCJ_ALB và copy DNS Name. Truy cập địa chỉ DNS của ALB, chúng ta sẽ được điều hướng tới các Fargate container đang host ứng dụng Calculator. Hãy chú ý bạn sẽ phải kết nối bằng HTTP. "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.4-target_group/",
	"title": "Tạo Target group",
	"tags": [],
	"description": "",
	"content": "Tạo Target group Chuyển tới EC2 console. Chuyển tới Target groups, chọn Create target group. Tạo target group: Mục Target type, chọn IP Adressess. Mục Target group name, nhập FCJ-TG. Kéo xuống chọn Create target group. Xác nhận target group đã được tạo thành công. "
},
{
	"uri": "//localhost:1313/vi/5-codepipeline/",
	"title": "AWS CodePipeline",
	"tags": [],
	"description": "",
	"content": "AWS CodePipeline là dịch vụ continuous delivery mà bạn có thể sử dụng để lập mô hình, trực quan hóa và tự động hóa các bước cần thiết để deploy phần mềm của mình. Bạn có thể nhanh chóng thiết lập mô hình, xác định cấu hình các giai đoạn khác nhau của quy trình phát hành phần mềm. CodePipeline tự động hóa các bước cần thiết để liên tục deploy các thay đổi phần mềm.\nTruy cập dịch vụ AWS CodePipeline. Ở menu bên trái, chọn Pipelines, sau đó Create pipeline. Mục Pipeline name, nhập FCJ_Pipeline. Các lựa chọn khác giữ nguyên mặc định như hình. Mục Advanced settings, Artifact store chọn Default location và Encryption key chọn Default AWS Managed key. Ấn Next. Tiếp tục: Mục Source provider, chọn AWS CodeCommit. Mục Repository name, chọn FCJ_Repo. Mục Branch name, chọn master. Còn lại giữ nguyên mặc định, sau đó nhấn Next. Click vào account góc phía trên cùng bên phải, sau đó copy Account ID của bạn. Tiếp tục: Mục Build provider, chọn AWS CodeBuild. Mục Region, chọn US East. Mục Project name, chọn FCJ_Build_Project. Nhấn Add enviroment variable. Mục Name, nhập AWS_ACCOUNT_ID. Mục Value hãy paste vào Account ID mà bạn đã copy trước đó. Còn lại giữ nguyên mặc định, sau đó nhấn Next. Nhấn Skip deploy stage, xác nhận Skip khi popup hiện ra. Kiếm tra lại cấu hình và nhấn Create pipeline. Xác nhận pipeline đã được tạo thành công. Chờ cho đến khi pipeline build thành công như trong hình. Truy cập tới dịch vụ AWS ECR, vào repo fcj-image-repo và xác nhận đã có 1 image được build và store thành công. "
},
{
	"uri": "//localhost:1313/vi/6-codedeploy/6.5-deploy_stage/",
	"title": "Cập nhật Deploy stage",
	"tags": [],
	"description": "",
	"content": "Cập nhật Deploy stage Truy cập tới dịch vụ AWS CodePipeline, chọn FCJ_Pipeline và chọn Edit. Nhấn Add stage sau stage Build. Nhập Deploy vào Stage name và nhấn Add stage. Nhấn Add action group cho stage Deploy. Thực hiện: Mục Action name, nhập DeployToECS. Mục Action provider, chọn Amazon ECS (Blue/Green). Mục Region, chọn US East (N. Virginia). Mục Input artifacts, chọn BuildArtifact. Mục AWS CodeDeploy application name, chọn application mà ECS đã tạo. Mục AWS CodeDeploy deployment group, chọn deployment group duy nhất. Tiếp tục: Mục Amazon ECS task definition, chọn BuildArtifact và nhập taskdef.json. Mục AWS CodeDeploy AppSpec file, chọn BuildArtifact và nhập appspec.yaml. Mục Input artifact with image details, chọn BuildArtifact. Mục Placeholder text in the task definition, nhập IMAGE1_NAME. Nhấn Done (không có trong hình). Nhấn Done để lưu stage. Kéo lên trên cùng nhấn Save và xác nhận. XÁc nhận pipeline đã có thêm stage Deploy, stage chưa được chạy vì chưa có gì trigger. "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.5-alb/",
	"title": "Tạo Application load balancer",
	"tags": [],
	"description": "",
	"content": "Tạo Application load balancer Chuyển hướng tới Load balancers, chọn Create load balancer. Chọn Application Load Balancer _ Mục Load balancer name, nhập FCJ-ALB. Mục Scheme, chọn Internet-facing (mặc định). Mục IP address type, chọn IPv4 (mặc định). Tại mục Network mapping: Mục VPC, chọn Default VPC. Mục Mappings, tick chọn cả 3 AZ, sau đó chọn các fcj-subnet tương ứng với từng AZ mà ta đã tạo. Tại mục Security groups, mở bảng dropdown, bỏ chọn default và chọn FCJ-SG. Tại mục Listeners and routing, tại Default action, chọn target group FCJ-TG. Kiểm tra lại cấu hình. Xác nhận ALB đã được tạo thành công. "
},
{
	"uri": "//localhost:1313/vi/6-codedeploy/",
	"title": "AWS CodeDeploy và AWS ECS",
	"tags": [],
	"description": "",
	"content": "Nội dung Tạo ECS Cluster Tạo Task definition Cập nhật code Tạo Cluster service Cập nhật Deploy stage Cập nhật và quan sát deployment "
},
{
	"uri": "//localhost:1313/vi/6-codedeploy/6.6-deployment/",
	"title": "Cập nhật và quan sát deployment",
	"tags": [],
	"description": "",
	"content": "Cập nhật và quan sát deployment Trở về source code, mở file src/components/Calculator.js. Thay đổi dòng 137 từ Version 1.0 sang 2.0. Thực hiện đẩy code lên repo: Chạy git add .. Chạy git commit -m \u0026quot;Update to 2.0\u0026quot; để commit code trên local. Chạy git push origin master để đẩy code lên repo trên CodeCommit. Trở về pipeline console, quan sát pipeline sẽ được trigger và chạy source Update to 2.0, và stage Deploy được chạy thành công. Trở về ECS console, vào xem tasks của cluster FCJ_Cluser, chúng ta sẽ thấy 3 task mới Running, đây chính là Green enviroment, trong khi đó 3 task cũ là Blue enviroment. Truy cập CodeDeploy, chọn Deployments từ menu bên trái, chúng ta sẽ thấy deployment của application đang In progress\u0026hellip;. Nhấn vào để xem chi tiết. Hình bên dưới đang cho thấy traffic gửi đến DNS name của FCJ_ALB đang được chuyển từ Blue enviroment (90%) sang Green enviroment (10%), đồng nghĩa với việc chuyển từ ứng dụng Version 1.0 sang 2.0. Chúng ta đã cấu hình cho việc này là 10% mỗi phút (bước 5 phần 6.4). Hãy mở một tab khác, hoặc một trình duyệt khác. Truy cập DNS name của FCJ_ALB (bước 17 phần 6.4). Hãy thử hard refresh (Ctrl + R) vài lần. Bạn sẽ thấy có lúc bạn nhận được Version 1.0, có lúc là Version 2.0. Thử nghiệm sẽ rõ ràng hơn khi có càng nhiều % traffic được chuyển từ Blue enviroment sang Green enviroment. 6 task, 3 task cho mỗi bên Blue và Green, sẽ cùng nhau tồn tại song song cho tới khi quá trình deploy thành công. Bạn có thể phân biệt cũ và mới bằng cách xem version của task definition. Như trong hình thì mới là 10 và cũ là 9. Hình này thể hiện việc tất cả traffic đã được chuyển từ Blue enviroment (0%) sang Green enviroment (100%). Từ đây, Blue enviroment hiện tại sẽ được terminate, Green enviroment hiện tại sẽ lên làm Blue enviroment mới. Step 3 của deployment sẽ đợi 15 phút (bước 13 phần 6.4) để chắc chắn hệ thống ổn định, nếu có gì gây ra deploy hỏng, hệ thống sẽ tự động roll back. Còn không, nếu mọi thứ ổn định thì Green enviroment hiện tại sẽ được terminate. 3 task của Blue enviroment cũ (task definition 9) đã được terminate và 3 task mới (task definition 10) sẽ lên làm Blue enviroment mới, phục vụ 100% traffic từ người dùng. Tất cả các step của deployment đã được thực hiện thành công. Xác nhận pipeline đã chạy source Update to 2.0 thành công. Vậy là bạn đã hoàn thành một Blue/Green deployment pipeline sử dụng AWS CodePipeline. "
},
{
	"uri": "//localhost:1313/vi/7-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": " Truy cập dịch vụ ECS, chọn cluster FCJ_Cluster, vào phần Services, chọn FCJ_Service, sau đó Delete service và xác nhận Delete. Sau khi xóa service, chọn Delete cluster để xóa cluster, xác nhận và nhấn Delete. Truy cập dịch vụ CloudFormation, xác nhận những stack có tên liên quan đến FCJ_Cluster đều đã được xóa thành công. Truy cập dịch vụ CodePipeline, chọn pipeline FCJ_Pipeline và Delete pipeline. Chọn CodeCommit ở menu bên trái, chọn repo FCJ_Repo và Delete repository. Chọn CodeBuild ở menu bên trái, chọn project FCJ_Build_Project, sau đó chọn Action và Delete. Truy cập dịch vụ S3, chọn bucket codepipeline-\u0026hellip; và xóa folder FCJ_Pipeline. Bạn có thể chọn giữ lại bucket này để triển khai những pipeline khác sau này hoặc xóa hoàn toàn bucket này. Truy cập dịch vụ ECR, chọn repo fcj_image_repo và Delete. Truy cập dịch vụ ECR, vào Roles và tìm codebuild, chọn role codebuildFCJ\u0026hellip; và Delete. Truy cập dịch vụ EC2, vào Load balancers, chọn FCJ_ALB, sau đó Actions và Delete load balancer. Tiếp tục trên console EC2, vào Target groups, chọn FCJ_TG, sau đó Actions và Delete. Truy cập dịch vụ VPC, vào Subnets, chọn 3 subnet fcj-subnet-\u0026hellip;, sau đó Actions và Delete subnet. Tiếp tục trên console VPC, vào Security groups, chọn FCJ_SG, sau đó Actions và Delete security groups. Truy cập dịch vụ CloudWatch, vào Log groups, chọn group aws/codebuild/FCJ_Build_Project, sau đó Actions và Delete log group(s). "
},
{
	"uri": "//localhost:1313/vi/8-ref/",
	"title": "Tài liệu tham khảo",
	"tags": [],
	"description": "",
	"content": "Tài liệu tham khảo https://d1.awsstatic.com/whitepapers/AWS_Blue_Green_Deployments.pdf https://stackoverflow.com/questions/69274998/could-not-connect-to-the-endpoint-url-https-api-ecr-public-xxxxxxxxx-amazona https://stackoverflow.com/questions/38587325/aws-ecr-getauthorizationtoken https://stackoverflow.com/questions/62022787/aws-ecs-blue-green-codepipeline-exception-while-trying-to-read-the-image-artifa https://stackoverflow.com/questions/60684118/aws-codedeploy-requires-two-target-groups-but-why "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]