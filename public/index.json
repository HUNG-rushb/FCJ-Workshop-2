[
{
	"uri": "//localhost:1313/",
	"title": "AWS Blue/Green Deployment",
	"tags": [],
	"description": "",
	"content": "AWS Blue/Green Deployment Overall In this workshop, we will build a Blue/Green pipeline using AWS CodePipeline and AWS ECS.\nDuration: 150 minutes. Prerequisite: git has been installed on the local machine, GitHub account, IDE, AWS account, IAM User/Role with AdministratorAcess. Content Introduce Prerequiste AWS CodeCommit AWS CodeBuild AWS CodePipeline AWS CodeDeploy and AWS ECS Clean up resources Reference "
},
{
	"uri": "//localhost:1313/3-codecommit/3.1-repo/",
	"title": "Create CodeCommit Repository",
	"tags": [],
	"description": "",
	"content": "Create CodeCommit Repository Go to CodeCommit console. At Repositories, choose Create repository. In the Repositorie name field, enter FCJ_Repo. Confirm that the repository has been created successfully. Press Clone URL, choose Clone HTTPS and go to the next step. "
},
{
	"uri": "//localhost:1313/6-codedeploy/6.1-cluster/",
	"title": "Create ECS Cluster",
	"tags": [],
	"description": "",
	"content": "Create ECS Cluster Access the AWS Elastic Container Service service, then choose Create cluster. In the Cluster name field, enter FCJ_Cluster. Confirm that the cluster has been created successfully. "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.1-git_credentials/",
	"title": "Create HTTPS Git Credentials for CodeCommit",
	"tags": [],
	"description": "",
	"content": "With Git credentials, you can create a username and static password in the IAM Console that you can use to access AWS CodeCommit from the command line, Git CLI, or any Git tool that supports HTTPS authentication.\nBecause these are static credentials, they can be cached using password management tools available in your local operating system or stored in a credential management utility. This allows you to get started with AWS CodeCommit in minutes. You don\u0026rsquo;t need to download the AWS CLI or configure Git client applications to connect to CodeCommit repositories over HTTPS. You can also use the username and password to connect to CodeCommit from third-party tools that support username and password authentication, including popular Git GUI client applications (such as TowerUI) and IDEs (such as Eclipse, IntelliJ, and Visual Studio).\nCreate HTTPS Git Credentials for CodeCommit From the root account, access the IAM console of the IAM account you will use for this lab, choose Security credentials. In the HTTPS Git credentials for AWS CodeCommit section, choose Generate credentials Choose Download credentials, and save it where you can easily access it again. "
},
{
	"uri": "//localhost:1313/4-codebuild/4.1-ecr_repo/",
	"title": "Create private repo ECR",
	"tags": [],
	"description": "",
	"content": "Create private repo ECR Go to Amazon Elastic Container Registry service. In the left menu, under Private registry, choose Repositories, then choose Create repository. Continue: In the Viability settings section, choose Private (default). In the Repository name field, enter fcj-image-repo. Scroll down and choose Create repository. Confirm that the private image repo has been created successfully. Open the source code folder you downloaded in the previous section using your IDE, then: Open the buildspec.yml file, at line 4, ECR_REPO_NAME, check and replace the repo name fcj-image-repo with your repo name if you are using a different name, if not, keep it as is. Save the file. "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "\nBlue/Green Deployment is a continuous deployment process that reduces downtime and risk by having two identical production environments, called Blue and Green.\nAssume the Blue environment is running and the Green environment is not. When developers want to release any new code - a new feature release, a new version of the application, etc. - work on the new version is done in the Green environment, while the old version is maintained in Blue. When the new release process is complete, the load balancer will switch all production traffic to the Green version, and the Blue version is maintained as a backup.\nThe advantages of the Blue/Green Deployment strategy are:\nTesting parity: this feature means that tests reflect the reality of production. Deploy anytime: no downtime means we can deploy anytime. No need to wait for maintenance windows. Instant rollback: the transition works both ways. If we decide to go back to the previous version, we can switch all users back immediately. Instant switchover: users are switched to the new version immediately, or nearly so. Everyone sees the latest release at the same time. Hot standby: Blue-Green can save us from disaster scenarios. Suppose a data center goes offline, we switch to another until the issue is resolved. This will work as long as we have a contingency plan that does not place Blue-Green in the same availability zone. Postmortem: debugging failed deployments is very difficult with in-place deployments. When faced with downtime, the priority is always to return to normal. Collecting debugging data is secondary, so much valuable information can be lost in the recovery process. Blue-green does not have this problem — Rollbacks always keep the failed deployment intact for analysis. Along with that, this strategy also has some disadvantages, such as:\nConsuming more resources because it needs to maintain 2 environments at the same time when deploying Blue/Green Deployment requires services on both environments to share a database, in case the new code affects changes in the database structure, a synchronization strategy needs to be built so that both environments can run simultaneously without incident. With this issue, we can use liquibase to build a solution. "
},
{
	"uri": "//localhost:1313/6-codedeploy/6.6-deployment/",
	"title": "Check logs",
	"tags": [],
	"description": "",
	"content": "Truy cập file và kiễm tra log Open new private tab and acces the file.\nIn buckets console, select bucket logging-workshop-destination, wait about 15 minutes, refresh the bucket.\nWe can see there are logs there, select one.\nSelect Download and open it.\nthe log file will looks like below:\nb07c1e6c73fc3be646182d0400a50638e0703b6352275b2d165aa35f9791c572 logging-workshop [03/Mar/2024:12:52:26 +0000] 118.69.159.186 arn:aws:iam::928738046450:user/hung 2ET0N53Y32R632Q5 REST.GET.OWNERSHIP_CONTROLS - \u0026#34;GET /logging-workshop?ownershipControls= HTTP/1.1\u0026#34; 200 - 193 - 53 53 \u0026#34;-\u0026#34; \u0026#34;S3Console/0.4, aws-internal/3 aws-sdk-java/1.12.488 Linux/5.10.209-175.858.amzn2int.x86_64 OpenJDK_64-Bit_Server_VM/25.372-b08 java/1.8.0_372 vendor/Oracle_Corporation cfg/retry-mode/standard\u0026#34; - xqa7XzBU4q1xnx4NmkVBFhDsnt0jk07Slo9F3j2kvD0/6zSveFBzQ5t+Zrfs/me6L4epr6/dG3k= SigV4 ECDHE-RSA-AES128-GCM-SHA256 AuthHeader s3.ap-southeast-1.amazonaws.com TLSv1.2 - -\rb07c1e6c73fc3be646182d0400a50638e0703b6352275b2d165aa35f9791c572 logging-workshop [03/Mar/2024:12:52:28 +0000] 118.69.159.186 arn:aws:iam::928738046450:user/hung YP9K97RHY7C5JPBC REST.GET.OBJECT_TAGGING S3_logging_workshop.txt \u0026#34;GET /logging-workshop/S3_logging_workshop.txt?tagging= HTTP/1.1\u0026#34; 200 - 115 - 13 10 \u0026#34;-\u0026#34; \u0026#34;S3Console/0.4, aws-internal/3 aws-sdk-java/1.12.488 Linux/5.10.209-175.858.amzn2int.x86_64 OpenJDK_64-Bit_Server_VM/25.372-b08 java/1.8.0_372 vendor/Oracle_Corporation cfg/retry-mode/standard\u0026#34; - nGxxv80fXE5xGWiS6C7OIg7/ncxoVho61Lmw9+qyveqdOBbiqRD4HJZf8qU90j0IeUXNGmwcSwA= SigV4 ECDHE-RSA-AES128-GCM-SHA256 AuthHeader s3.ap-southeast-1.amazonaws.com TLSv1.2 - - "
},
{
	"uri": "//localhost:1313/4-codebuild/4.2-build_project/",
	"title": "Create CodeBuild Project",
	"tags": [],
	"description": "",
	"content": "Create CodeBuild Project Move to the CodeBuild service, on the left menu choose Build projects, then select Create project. Then: In the Project name field, enter FCJ_Build_Project. In the Source 1 - Primary field, choose provider AWS CodeCommit, then select repo FCJ_Repo. In the Branch field, choose master. Open the Additional configuration section, then tick Enable this flag if you want to build Docker images or want your builds to get elevated privileges. In the Buildspec section, tick Use a buildspec file, enter buildspec.yml. Scroll down and choose Create build project. Confirm that the build project has been created successfully. "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.2-public_subnet/",
	"title": "Create Public Subnet",
	"tags": [],
	"description": "",
	"content": " Go to VPC console, and check if you have Default VPC or not. Choose Subnets in the navigation pane on the left, and then choose Create subnet. Choose Default VPC. Create subnet 1: In the Subnet name field, enter fcj-subnet-1. In the Availability zone field, choose us-east-1a. In the IPv4 subnet CIDR block field, enter 172.31.200.0/24. Choose Add new subnet, and create subnet 2: In the Subnet name field, enter fcj-subnet-1. In the Availability zone field, choose us-east-1b. In the IPv4 subnet CIDR block field, enter 172.31.201.0/24. Choose Add new subnet, and create subnet 3: In the Subnet name field, enter fcj-subnet-1. In the Availability zone field, choose us-east-1c. In the IPv4 subnet CIDR block field, enter 172.31.202.0/24. Choose Create subnet. Confirm that 3 subnets have been created successfully. "
},
{
	"uri": "//localhost:1313/6-codedeploy/6.2-task_def/",
	"title": "Create Task definition",
	"tags": [],
	"description": "",
	"content": "Create Task definition Access to AWS Elastic Container Service, select Task definitions, then select Create new task definition continuously 2 times. //translate below to english\nIn Task definition family, enter FCJ_Task_Definition. In Infrastructure requirements, do: In Launch type, select AWS Fargate. In Task size, CPU select .5 vCPU, Memory select 2GB. In Task role, select ecsTaskExecutionRole. In Task execution role, select ecsTaskExecutionRole. Access AWS ECR, go to repo fci_image_repo and copy latest image URI as in the image. In Containner - 1, do: In Name, enter fcj_container. In Image URI, paste the image URI you copied in step 4. Confirm that the task definition has been created successfully. "
},
{
	"uri": "//localhost:1313/2-prerequiste/",
	"title": "Preparation ",
	"tags": [],
	"description": "",
	"content": "Content Create HTTPS Git Credentials for CodeCommit Create Public Subnet Create Security Group Create Target Group Create Application Load Balancer "
},
{
	"uri": "//localhost:1313/3-codecommit/3.2-code/",
	"title": "Push Code to CodeCommit Repository",
	"tags": [],
	"description": "",
	"content": "Download source code Access this link https://github.com/HUNG-rushb/React-Calculator/releases/tag/v1 and download the source code. This is a simple Calculator App written in React that we will use to deploy. Download and extract it to the directory you want to work in. Check if the files are complete as shown below. Push code to CodeCommit repo Inside that directory: Run git init to create a git repo. Run git remote add origin PASTE_HTTPS_REPO_LINK_HERE, replace PASTE_HTTPS_REPO_LINK_HERE with the HTTPS link you copied in the previous section. Run git add .. Run git commit -m \u0026quot;init\u0026quot; to commit the code locally (not in the image). Continue: Run git push origin master to push the code to the repo on CodeCommit. Git will ask you for Username and Password, this is the credentials in the codecommit credentials file that we created in the Create HTTPS Git Credentials for CodeCommit section. Open the file credentials, copy username and password into cmd. Enter and confirm that the code has been successfully pushed. Return to the tab you are opening AWS, move to the CodeCommit service and into your repo, you will see the code has been successfully pushed. On the left menu, choose Commits and check the most recent commit is yours, in the image is init. "
},
{
	"uri": "//localhost:1313/3-codecommit/",
	"title": "AWS CodeCommit",
	"tags": [],
	"description": "",
	"content": "\nContent Create CodeCommit Repository Push Code to Repository "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.3-security_group/",
	"title": "Create Security Group",
	"tags": [],
	"description": "",
	"content": "Create Security Group Go to Security Groups console, and choose Create security group. Create security group: In the Security group name field, enter FCJ_SG.\nIn the Description field, enter Allow inbound HTTP on port 80.\nIn the VPC field, choose Default VPC.\nIn the Inbound rules field, choose Add rule, Type choose HTTP, Source choose Anywhere-IPv4.\nScroll down, and choose Create security group (not shown in the image).\n"
},
{
	"uri": "//localhost:1313/6-codedeploy/6.3-code/",
	"title": "Update code",
	"tags": [],
	"description": "",
	"content": "Update code Access AWS ECS, go to Task definitions, and select the task FCJ_Task_Definition that you have created. Select the JSON tab, then Copy to clipboard. From the source code, open the file taskdef.json in your IDE. Replace the entire content in that file with the task definition you copied in step 1. At line 6, where the key image is located, replace its value with \u0026lt;IMAGE1_NAME\u0026gt;. Scroll down to the end or search in the IDE for the term tags, you will find \u0026ldquo;tags\u0026rdquo;: [], delete it. Open the file appspec.yml, at line 8, ContainerName, replace the value with fcj_container. This is the container name you set in step 5 of section 6.2, you can also find \u0026ldquo;name\u0026rdquo;: \u0026ldquo;fcj_container\u0026rdquo; in the task definition in the file taskdef.json. Push the code to the repo: Run git add .. Run git commit -m \u0026quot;Update config\u0026quot; to commit the code locally. Run git push origin master to push the code to the repo on CodeCommit. Open your pipeline and observe. After all stages are successful, access AWS S3, find and select the bucket codepipeline-us-east-1-\u0026hellip;\u0026hellip;. This is the bucket that CodePipeline creates to store artifacts. Each region will have a corresponding bucket for the pipeline region. Select the folder named FCJ_Pipeline. Select the folder BuildArtif. Click on the Last modified tab to sort by time, select the most recent item, click Download to download. Unzip and check to confirm that the content is correct with what you have edited in the steps above. If so, our artifact has been built successfully. "
},
{
	"uri": "//localhost:1313/4-codebuild/4.3-role/",
	"title": "Update CodeBuild Role",
	"tags": [],
	"description": "",
	"content": "Update CodeBuild Role Access the IAM service: On the left menu, choose Roles. Search for codebuild. Select the codebuild role corresponding to your project. Choose Add permissions, then Create inline policy. Copy and paste the policy below into the Policy editor. Then scroll down and choose Next. { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ecr-public:GetAuthorizationToken\u0026#34;, \u0026#34;sts:GetServiceBearerToken\u0026#34;, \u0026#34;ecr-public:BatchCheckLayerAvailability\u0026#34;, \u0026#34;ecr-public:GetRepositoryPolicy\u0026#34;, \u0026#34;ecr-public:DescribeRepositories\u0026#34;, \u0026#34;ecr-public:DescribeRegistries\u0026#34;, \u0026#34;ecr-public:DescribeImages\u0026#34;, \u0026#34;ecr-public:DescribeImageTags\u0026#34;, \u0026#34;ecr-public:GetRepositoryCatalogData\u0026#34;, \u0026#34;ecr-public:GetRegistryCatalogData\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } In the Policy name field, enter FCJ_ECR_Public_Access. Then press Create policy. Confirm that the policy has been added successfully. Continue to choose Add permissions, then Attach policies. Search for AmazonEC2ContainerRegistryFullAccess. Select and press Add permissions. Confirm that the policy has been added successfully. "
},
{
	"uri": "//localhost:1313/4-codebuild/",
	"title": "AWS CodeBuild",
	"tags": [],
	"description": "",
	"content": " Content Create private ECR repo Create CodeBuild project Update CodeBuild role "
},
{
	"uri": "//localhost:1313/6-codedeploy/6.4-service/",
	"title": "Creat Cluster service",
	"tags": [],
	"description": "",
	"content": "Create Cluster service Access to AWS ECS, select Clusters, and choose the cluster FCJ_Cluster. Choose Create in the Services tab. In Compute options, choose Launch type, and select Fargate (default), Platform version is LATEST. At Deployment configuration: In Application type, choose Service. In Family, choose FCJ_Task_Definition, Revision automatically selects the LATEST version. In Project name, choose FCJ_Build_Project. In Service name, enter FCJ_Service. In Desired tasks, enter 3. Continue: In Deployment options, choose Blue/green deployment (powered by AWS CodeDeploy). In Deployment configuration, choose CodeDeployDefault.ECSLinear10PercentEvery1Minutes. In Service role for CodeDeploy, choose CodeDeployServiceRole. In Networking: In VPC, choose Default VPC. In Subnets, choose 3 public subnets fcj-subnet-\u0026hellip;. In Security group, choose Use an existing security group, then add FCJ_SG, there will be 2 security groups as shown in the image. In Public IP, choose Turned on. In Load balancing: In Load balancer type, choose Application Load Balancer. In Application Load Balancer, choose Use an existing load balancer. In Load balancer, choose FCJ_ALB. In Health check grace periodInfo, enter 0. Continue: In Listeners and Production listener, choose Use an existing listener and select 80:HTTP. Check target group is FCJ_TG. In Target groups: In Application type, choose Service. In Target group 1, choose Use an existing target group and then choose FCJ_TG in the dropdown on the right. In Target group 2, choose Create new target group. In Target group 2 name, enter FCJ-TG-Blue. Then scroll down to the bottom and choose Create (not in the image). //translate below to english\nAccess to AWS CloudFormation, we will see a new stack being created, this is the stack that contains our service. After the stack is created successfully, access the AWS CodeDeploy service, go to Applications, we will see an application in the form of AppECS-\u0026hellip;. This is the application that ECS uses to deploy the application. Click on the application to observe. Choose the Deployment groups tab, select the only deployment group in it, and choose Edit. Scroll down to the bottom, in the Deployment settings section, change the Original revision termination time to 0 hour 15 minutes as shown in the image. Press Save changes. Return to the ECS console, check the Services of the cluster, we will see FCJ_Service running successfully. Switch to the Tasks tab, we will see 3 tasks Running. Access the AWS EC2 service, go to Load balancers, select FCJ_ALB and copy the DNS Name. Access the DNS address of the ALB, we will be directed to the Fargate container hosting the Calculator application. Note that you will have to connect via HTTP.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.4-target_group/",
	"title": "Create Target Group",
	"tags": [],
	"description": "",
	"content": "Create Target Group Go to EC2 console. Choose Target groups, and then choose Create target group. Create target group: In the Target type field, choose IP Adressess. In the Target group name field, enter FCJ-TG. Scroll down, and choose Create target group. Confirm that the target group has been created successfully. "
},
{
	"uri": "//localhost:1313/5-codepipeline/",
	"title": "AWS CodePipeline",
	"tags": [],
	"description": "",
	"content": "AWS CodePipeline là dịch vụ continuous delivery mà bạn có thể sử dụng để lập mô hình, trực quan hóa và tự động hóa các bước cần thiết để deploy phần mềm của mình. Bạn có thể nhanh chóng thiết lập mô hình, xác định cấu hình các giai đoạn khác nhau của quy trình phát hành phần mềm. CodePipeline tự động hóa các bước cần thiết để liên tục deploy các thay đổi phần mềm.\nTruy cập dịch vụ AWS CodePipeline. Ở menu bên trái, chọn Pipelines, sau đó Create pipeline. Mục Pipeline name, nhập FCJ_Pipeline. Các lựa chọn khác giữ nguyên mặc định như hình. Mục Advanced settings, Artifact store chọn Default location và Encryption key chọn Default AWS Managed key. Ấn Next. Tiếp tục: Mục Source provider, chọn AWS CodeCommit. Mục Repository name, chọn FCJ_Repo. Mục Branch name, chọn master. Còn lại giữ nguyên mặc định, sau đó nhấn Next. Click vào account góc phía trên cùng bên phải, sau đó copy Account ID của bạn. Tiếp tục: Mục Build provider, chọn AWS CodeBuild. Mục Region, chọn US East. Mục Project name, chọn FCJ_Build_Project. Nhấn Add enviroment variable. Mục Name, nhập AWS_ACCOUNT_ID. Mục Value hãy paste vào Account ID mà bạn đã copy trước đó. Còn lại giữ nguyên mặc định, sau đó nhấn Next. Nhấn Skip deploy stage, xác nhận Skip khi popup hiện ra. Kiếm tra lại cấu hình và nhấn Create pipeline. Xác nhận pipeline đã được tạo thành công. Chờ cho đến khi pipeline build thành công như trong hình. Truy cập tới dịch vụ AWS ECR, vào repo fcj-image-repo và xác nhận đã có 1 image được build và store thành công. "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.5-alb/",
	"title": "Create Application Load Balancer",
	"tags": [],
	"description": "",
	"content": "Create Application Load Balancer Go to Load balancers, and choose Create load balancer. Choose Application Load Balancer _ In the Load balancer name field, enter FCJ-ALB. In the Scheme field, choose Internet-facing (default). In the IP address type field, choose IPv4 (default). In the Network mapping section: In the VPC field, choose Default VPC. In the Mappings field, tick all 3 AZ, then choose the corresponding fcj-subnet for each AZ that we have created. In the Security groups section, open the dropdown, uncheck default and choose FCJ-SG. In the Listeners and routing section, at Default action, choose target group FCJ-TG. Check the configuration again. Confirm that the ALB has been created successfully. "
},
{
	"uri": "//localhost:1313/6-codedeploy/6.5-deploy_stage/",
	"title": "Update Deploy stage",
	"tags": [],
	"description": "",
	"content": "Update Deploy stage Access AWS CodePipeline, select FCJ_Pipeline, and choose Edit. Click Add stage after the Build stage. Enter Deploy into Stage name and click Add stage. Click Add action group for the Deploy stage. Perform: In Action name, enter DeployToECS. In Action provider, choose Amazon ECS (Blue/Green). In Region, choose US East (N. Virginia). In Input artifacts, choose BuildArtifact. In AWS CodeDeploy application name, choose the application that ECS has created. In AWS CodeDeploy deployment group, choose the unique deployment group. Continue: In Amazon ECS task definition, choose BuildArtifact and enter taskdef.json. In AWS CodeDeploy AppSpec file, choose BuildArtifact and enter appspec.yaml. In Input artifact with image details, choose BuildArtifact. In Placeholder text in the task definition, enter IMAGE1_NAME. Click Done (not shown in the image). Click Done to save the stage. Scroll to the top and click Save and confirm. Confirm the pipeline has added the Deploy stage, the stage has not run because there is no trigger. "
},
{
	"uri": "//localhost:1313/6-codedeploy/",
	"title": "Clean up",
	"tags": [],
	"description": "",
	"content": "We will take the following steps to delete the resources we created in this exercise.\nXóa Athena query Find and select service Athena, then select Launch query editor, select tab Settings, click Manage.\nClick X to delete the connections to bucket, click Save.\nXóa CloudTrail Find and select service CloudTrail, select Trails on left panel. Select trail S3_logging_workshop, then select Delete.\nConfirm Delete.\nXóa S3 buckets Find and select service S3, select bucket logging_workshop. We have to empty the bucket before delete it. Select all files then click Delete.\nConfirmto delete. click Delete objects.\nReturn to buckets list, then select bucket logging_workshop, select Delete.\nConfirm bucket\u0026rsquo;s name and click Delete bucket.\nRepeat delete step from step 5 to delete 2 remainings buckets, logging-workshop-destinations và aws-cloudtrail-log-workshop.\n"
},
{
	"uri": "//localhost:1313/7-cleanup/",
	"title": "Clean up",
	"tags": [],
	"description": "",
	"content": "We will take the following steps to delete the resources we created in this exercise.\nXóa Athena query Find and select service Athena, then select Launch query editor, select tab Settings, click Manage.\nClick X to delete the connections to bucket, click Save.\nXóa CloudTrail Find and select service CloudTrail, select Trails on left panel. Select trail S3_logging_workshop, then select Delete.\nConfirm Delete.\nXóa S3 buckets Find and select service S3, select bucket logging_workshop. We have to empty the bucket before delete it. Select all files then click Delete.\nConfirmto delete. click Delete objects.\nReturn to buckets list, then select bucket logging_workshop, select Delete.\nConfirm bucket\u0026rsquo;s name and click Delete bucket.\nRepeat delete step from step 5 to delete 2 remainings buckets, logging-workshop-destinations và aws-cloudtrail-log-workshop.\n"
},
{
	"uri": "//localhost:1313/8-ref/",
	"title": "Clean up",
	"tags": [],
	"description": "",
	"content": "We will take the following steps to delete the resources we created in this exercise.\nXóa Athena query Find and select service Athena, then select Launch query editor, select tab Settings, click Manage.\nClick X to delete the connections to bucket, click Save.\nXóa CloudTrail Find and select service CloudTrail, select Trails on left panel. Select trail S3_logging_workshop, then select Delete.\nConfirm Delete.\nXóa S3 buckets Find and select service S3, select bucket logging_workshop. We have to empty the bucket before delete it. Select all files then click Delete.\nConfirmto delete. click Delete objects.\nReturn to buckets list, then select bucket logging_workshop, select Delete.\nConfirm bucket\u0026rsquo;s name and click Delete bucket.\nRepeat delete step from step 5 to delete 2 remainings buckets, logging-workshop-destinations và aws-cloudtrail-log-workshop.\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]